<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Registers · Documentation | Yao</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/><link href="https://yaoquantum.org/assets/favicon-light.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Documentation | Yao logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Documentation | Yao</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../quick-start.html">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href="registers.html">Quantum Registers</a><ul class="internal"><li><a class="tocitem" href="#Storage"><span>Storage</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li><li><a class="tocitem" href="#Resource-management-and-addressing"><span>Resource management and addressing</span></a></li><li><a class="tocitem" href="#Instruction-set"><span>Instruction set</span></a></li><li><a class="tocitem" href="#Measurement"><span>Measurement</span></a></li><li><a class="tocitem" href="#Density-matrices"><span>Density matrices</span></a></li></ul></li><li><a class="tocitem" href="blocks.html">Blocks</a></li><li><a class="tocitem" href="symbolic.html">Symbolic Computation</a></li><li><a class="tocitem" href="automatic_differentiation.html">Automatic Differentiation</a></li><li><a class="tocitem" href="simplification.html">Simplification</a></li><li><a class="tocitem" href="bitbasis.html">BitBasis</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/1.prepare-ghz-state/index.html">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="tocitem" href="../generated/examples/2.qft-phase-estimation/index.html">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="tocitem" href="../generated/examples/3.grover-search/index.html">Grover Search</a></li><li><a class="tocitem" href="../generated/examples/4.shor-algorithm/index.html">Shor&#39;s Algorithm</a></li><li><a class="tocitem" href="../generated/examples/5.shor-9-code/index.html">Shor&#39;s 9 qubit code</a></li><li><a class="tocitem" href="../generated/examples/6.quantum-circuit-born-machine/index.html">Quantum Circuit Born Machine</a></li><li><a class="tocitem" href="../generated/examples/7.variation-quantum-eigen-solver/index.html">Variational Quantum Eigen Solver</a></li></ul></li><li><a class="tocitem" href="../performancetips.html">Performance Tips</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="registers.html">Quantum Registers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="registers.html">Quantum Registers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/man/registers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="registers"><a class="docs-heading-anchor" href="#registers">Quantum Registers</a><a id="registers-1"></a><a class="docs-heading-anchor-permalink" href="#registers" title="Permalink"></a></h1><p>A quantum register is a quantum state or a batch of quantum states. <code>Yao</code> provides two types of quantum registers <a href="registers.html#YaoArrayRegister.ArrayReg"><code>ArrayReg</code></a> and <a href="registers.html#YaoArrayRegister.BatchedArrayReg"><code>BatchedArrayReg</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.AbstractRegister" href="#YaoAPI.AbstractRegister"><code>YaoAPI.AbstractRegister</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRegister{D}</code></pre><p>Abstract type for quantum registers. Type parameter <code>D</code> is the number of levels in each qudit. For qubits, <code>D = 2</code>.</p><p><strong>Required methods</strong></p><ul><li><p><a href="registers.html#YaoAPI.instruct!"><code>instruct!</code></a></p></li><li><p><a href="registers.html#YaoAPI.nqudits"><code>nqudits</code></a></p></li><li><p><a href="registers.html#YaoAPI.nactive"><code>nactive</code></a></p></li><li><p><a href="man/@ref"><code>insert_qubits!</code></a></p></li><li><p><a href="registers.html#YaoAPI.append_qubits!"><code>append_qubits!</code></a></p></li><li><p><a href="man/@ref"><code>focus!</code></a></p></li><li><p><a href="registers.html#YaoAPI.relax!"><code>relax!</code></a></p></li><li><p><a href="registers.html#YaoAPI.reorder!"><code>reorder!</code></a></p></li><li><p><a href="registers.html#YaoAPI.invorder!"><code>invorder!</code></a></p></li></ul><p><strong>Optional methods</strong></p><ul><li><a href="man/@ref"><code>nlevel</code></a></li><li><a href="registers.html#YaoAPI.nremain"><code>nremain</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L3-L29">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AbstractArrayReg</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.ArrayReg" href="#YaoArrayRegister.ArrayReg"><code>YaoArrayRegister.ArrayReg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArrayReg{D,T,MT&lt;:AbstractMatrix{T}} &lt;: AbstractArrayRegister{D}
ArrayReg{D}(raw)
ArrayReg(raw::AbstractVecOrMat; nlevel=2)
ArrayReg(r::ArrayReg)</code></pre><p>Simulated full amplitude register type, it uses an array to represent corresponding one or a batch of quantum states. <code>T</code> is the numerical type for each amplitude, it is <code>ComplexF64</code> by default.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>ArrayReg</code> constructor will not normalize the quantum state. If you need a normalized quantum state remember to use <code>normalize!(register)</code> on the register or normalize the input raw array with <code>normalize</code> or <a href="man/@ref"><code>batched_normalize!</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L16-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.BatchedArrayReg" href="#YaoArrayRegister.BatchedArrayReg"><code>YaoArrayRegister.BatchedArrayReg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchedArrayReg{D,T,MT&lt;:AbstractMatrix{T}} &lt;: AbstractArrayReg{D}
BatchedArrayReg(raw, nbatch; nlevel=2)
BatchedArrayReg{D}(raw, nbatch)</code></pre><p>Simulated batched full amplitude register type, it uses an array to represent corresponding one or a batch of quantum states. <code>T</code> is the numerical type for each amplitude, it is <code>ComplexF64</code> by default.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>BatchedArrayReg</code> constructor will not normalize the quantum state. If you need a normalized quantum state remember to use <code>normalize!(register)</code> on the register or normalize the input raw array with <code>normalize</code> or <a href="man/@ref"><code>batched_normalize!</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L54-L68">source</a></section></article><p>We define some shortcuts to create simulated quantum states easier:</p><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.arrayreg" href="#YaoArrayRegister.arrayreg"><code>YaoArrayRegister.arrayreg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">arrayreg(state; nbatch::Union{Integer,NoBatch}=NoBatch(), nlevel::Integer=2)</code></pre><p>Create an array register, if nbatch is a integer, it will return a <code>BatchedArrayReg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L124-L128">source</a></section><section><div><pre><code class="nohighlight hljs">arrayreg([T=ComplexF64], bit_str; nbatch=NoBatch())</code></pre><p>Construct an array register from bit string literal. For bit string literal please read <a href="bitbasis.html#BitBasis.@bit_str-Tuple{Any}"><code>@bit_str</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; arrayreg(bit&quot;1010&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; arrayreg(ComplexF32, bit&quot;1010&quot;)
ArrayReg{2, ComplexF32, Array...}
    active qubits: 4/4
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L177-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.product_state" href="#YaoArrayRegister.product_state"><code>YaoArrayRegister.product_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">product_state([T=ComplexF64], dit_str; nbatch=NoBatch(), no_transpose_storage=false)
product_state([T=ComplexF64], nbits::Int, val::Int; nbatch=NoBatch(), nlevel=2, no_transpose_storage=false)
product_state([T=ComplexF64], vector; nbatch=NoBatch(), nlevel=2, no_transpose_storage=false)</code></pre><p>Create an <a href="registers.html#YaoArrayRegister.ArrayReg"><code>ArrayReg</code></a> of product state. The configuration can be specified with a dit string, which can be defined with <a href="bitbasis.html#BitBasis.@bit_str-Tuple{Any}"><code>@bit_str</code></a> or <a href="bitbasis.html#BitBasis.@dit_str-Tuple{Any}"><code>@dit_str</code></a>. Or equivalently, it can be specified explicitly with <code>nbits</code>, <code>val</code> and <code>nlevel</code>. See also <a href="registers.html#YaoArrayRegister.zero_state"><code>zero_state</code></a>, <a href="registers.html#YaoArrayRegister.rand_state"><code>rand_state</code></a>, <a href="registers.html#YaoArrayRegister.uniform_state"><code>uniform_state</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(dit&quot;120;3&quot;; nbatch=2)
BatchedArrayReg{3, ComplexF64, Transpose...}
    active qudits: 3/3
    nlevel: 3
    nbatch: 2

julia&gt; measure(reg)
1×2 Matrix{BitBasis.DitStr64{3, 3}}:
 120 ₍₃₎  120 ₍₃₎

julia&gt; product_state(bit&quot;100&quot;; nbatch=2);

julia&gt; r1 = product_state(ComplexF32, bit&quot;001&quot;; nbatch=2);

julia&gt; r2 = product_state(ComplexF32, [1, 0, 0]; nbatch=2);

julia&gt; r3 = product_state(ComplexF32, 3, 0b001; nbatch=2);

julia&gt; r1 ≈ r2   # because we read bit strings from right to left, vectors from left to right.
true

julia&gt; r1 ≈ r3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L444-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.zero_state" href="#YaoArrayRegister.zero_state"><code>YaoArrayRegister.zero_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zero_state([T=ComplexF64], n::Int; nbatch::Int=NoBatch())</code></pre><p>Create an <a href="man/@ref"><code>AbstractArrayReg</code></a> that initialized to state <span>$|0\rangle^{\otimes n}$</span>. See also <a href="registers.html#YaoArrayRegister.product_state"><code>product_state</code></a>, <a href="registers.html#YaoArrayRegister.rand_state"><code>rand_state</code></a>, <a href="registers.html#YaoArrayRegister.uniform_state"><code>uniform_state</code></a> and <a href="registers.html#YaoArrayRegister.ghz_state"><code>ghz_state</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; zero_state(4)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; zero_state(ComplexF32, 4)
ArrayReg{2, ComplexF32, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; zero_state(ComplexF32, 4; nbatch=3)
BatchedArrayReg{2, ComplexF32, Transpose...}
    active qubits: 4/4
    nlevel: 2
    nbatch: 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L516-L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.zero_state_like" href="#YaoArrayRegister.zero_state_like"><code>YaoArrayRegister.zero_state_like</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zero_state_like(register, n) -&gt; AbstractRegister</code></pre><p>Create a register initialized to zero from an existing one.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = rand_state(3; nbatch=2)
BatchedArrayReg{2, ComplexF64, Transpose...}
    active qubits: 3/3
    nlevel: 2
    nbatch: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L252-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.rand_state" href="#YaoArrayRegister.rand_state"><code>YaoArrayRegister.rand_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rand_state([T=ComplexF64], n::Int; nbatch=NoBatch(), no_transpose_storage=false)</code></pre><p>Create a random <a href="man/@ref"><code>AbstractArrayReg</code></a> with total number of qudits <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rand_state(4)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; rand_state(ComplexF64, 4)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; rand_state(ComplexF64, 4; nbatch=2)
BatchedArrayReg{2, ComplexF64, Transpose...}
    active qubits: 4/4
    nlevel: 2
    nbatch: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L571-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.uniform_state" href="#YaoArrayRegister.uniform_state"><code>YaoArrayRegister.uniform_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uniform_state([T=ComplexF64], n; nbatch=NoBatch(), no_transpose_storage=false)</code></pre><p>Create a uniform state:</p><p class="math-container">\[\frac{1}{\sqrt{2^n}} \sum_{k=0}^{2^{n}-1} |k\rangle.\]</p><p>This state can also be created by applying <a href="man/@ref"><code>H</code></a> (Hadmard gate) on <span>$|00⋯00⟩$</span> state.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; uniform_state(4; nbatch=2)
BatchedArrayReg{2, ComplexF64, Transpose...}
    active qubits: 4/4
    nlevel: 2
    nbatch: 2

julia&gt; uniform_state(ComplexF32, 4; nbatch=2)
BatchedArrayReg{2, ComplexF32, Transpose...}
    active qubits: 4/4
    nlevel: 2
    nbatch: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L611-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.ghz_state" href="#YaoArrayRegister.ghz_state"><code>YaoArrayRegister.ghz_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghz_state([T=ComplexF64], n::Int; nbatch::Int=NoBatch())</code></pre><p>Create a GHZ state (or a cat state) that defined as</p><p class="math-container">\[\frac{|0\rangle^{\otimes n} + |1\rangle^{\otimes n}}{\sqrt{2}}.\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ghz_state(4)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L545-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.clone" href="#YaoAPI.clone"><code>YaoAPI.clone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clone(register, n)</code></pre><p>Create an <a href="man/@ref"><code>ArrayReg</code></a> by cloning the original <code>register</code> for <code>n</code> times on batch dimension. This function is only for emulation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; clone(arrayreg(bit&quot;101&quot;; nbatch=3), 4)
BatchedArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2
    nbatch: 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L782-L797">source</a></section></article><p>In a register, qubits are distinguished as active and inactive (or remaining). The total number of qubits is the number of active qubits plus the number of remaining qubits.  Only active qubits are visible to quantum operators and the number of these qubits are the <em>size</em> of a register. Making this distinction of qubits allows writing reusable quantum circuits. For example, Suppose we want to run a quantum Fourier transformation circuit of size 4 on qubits <code>(1, 3, 5, 7)</code>, we first set the target qubits to active qubits the reset to inactive, then we apply the circuit on it, finally we unset the inactive qubits.</p><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.nqudits" href="#YaoAPI.nqudits"><code>YaoAPI.nqudits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nqudits(register) -&gt; Int</code></pre><p>Returns the total number of qudits in <code>register</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.nqubits" href="#YaoAPI.nqubits"><code>YaoAPI.nqubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nqubits(register) -&gt; Int</code></pre><p>Returns the (total) number of qubits. See <a href="registers.html#YaoAPI.nactive"><code>nactive</code></a>, <a href="registers.html#YaoAPI.nremain"><code>nremain</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.nactive" href="#YaoAPI.nactive"><code>YaoAPI.nactive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nactive(register) -&gt; Int</code></pre><p>Returns the number of active qudits in <code>register</code>. Here, active qudits means the system qubits that operators can be applied on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.nremain" href="#YaoAPI.nremain"><code>YaoAPI.nremain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nremain(register) -&gt; Int</code></pre><p>Returns the number of inactive qudits in <code>register</code>. It equals to subtracting <a href="registers.html#YaoAPI.nqudits"><code>nqudits</code></a> and <a href="registers.html#YaoAPI.nactive"><code>nactive</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L84-L89">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>nbatch, nlevel, focus!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.focus" href="#YaoAPI.focus"><code>YaoAPI.focus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">focus(f, register, locs)</code></pre><p>Call a callable <code>f</code> under the context of <code>focus</code>. See also <a href="man/@ref"><code>focus!</code></a>.</p><p><strong>Examples</strong></p><p>To print the focused register</p><pre><code class="language-julia-repl hljs">julia&gt; r = arrayreg(bit&quot;101100&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 6/6
    nlevel: 2

julia&gt; focus(x-&gt;(println(x);x), r, (1, 2));
ArrayReg{2, ComplexF64, Array...}
    active qubits: 2/6
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L233-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.relax!" href="#YaoAPI.relax!"><code>YaoAPI.relax!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relax!(register[, locs]; to_nactive=nqudits(register)) -&gt; register
relax!(locs::Int...; to_nactive=nqudits(register)) -&gt; f(register) -&gt; register</code></pre><p>Inverse transformation of <a href="man/@ref"><code>focus!</code></a>, where <code>to_nactive</code> is the number  of active bits for target register. If the register is not provided, returns a lambda function that takes a register as input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;01101&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2

julia&gt; focus!(reg, (1,3,4))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/5
    nlevel: 2

julia&gt; relax!(reg, (1,3,4))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L256-L282">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>zero_state</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.exchange_sysenv" href="#YaoArrayRegister.exchange_sysenv"><code>YaoArrayRegister.exchange_sysenv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exchange_sysenv(reg::AbstractArrayReg) -&gt; AbstractRegister</code></pre><p>Exchange system (focused qubits) and environment (remaining qubits).</p><pre><code class="language-julia-repl hljs">julia&gt; reg = rand_state(5)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2

julia&gt; focus!(reg, (2,4))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 2/5
    nlevel: 2

julia&gt; exchange_sysenv(reg)
ArrayReg{2, ComplexF64, Adjoint...}
    active qubits: 3/5
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/focus.jl#L133-L154">source</a></section></article><h2 id="Storage"><a class="docs-heading-anchor" href="#Storage">Storage</a><a id="Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Storage" title="Permalink"></a></h2><p>Both <a href="man/@reef"><code>ArayReg</code></a> and <a href="registers.html#YaoArrayRegister.BatchedArrayReg"><code>BatchedArrayReg</code></a> use matrices as the storage. For example, for a quantum register with <span>$a$</span> active qubits, <span>$r$</span> remaining qubits and batch size <span>$b$</span>, the storage is as follows</p><p><img src="../assets/images/regstorage.svg" alt/></p><p>The first dimension of size <span>$2^a$</span> is for active qubits, only this subset of qubits are allowed to interact with blocks. Since we reshaped the state vector into a matrix, applying a quantum operator can always be represented as a matrix-matrix multiplication . In practice, most gates have in-place implementation that does not require constructing the operator matrix explicitly.</p><p>You can access different views of the storage of an <a href="registers.html#YaoArrayRegister.ArrayReg"><code>ArrayReg</code></a> with the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.state" href="#YaoArrayRegister.state"><code>YaoArrayRegister.state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">state(register::AbstractArrayReg) -&gt; Matrix</code></pre><p>Returns the raw array storage of <code>register</code>. See also <a href="registers.html#YaoArrayRegister.statevec"><code>statevec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L360-L364">source</a></section><section><div><pre><code class="nohighlight hljs">state(ρ::DensityMatrix) -&gt; Matrix</code></pre><p>Return the raw state of density matrix <code>ρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/density_matrix.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BitBasis.basis" href="#BitBasis.basis"><code>BitBasis.basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis(ditstr) -&gt; UnitRange{DitStr{D,N,T}}
basis(DitStr{D,N,T}) -&gt; UnitRange{DitStr{D,N,T}}</code></pre><p>Returns the <code>UnitRange</code> for basis in Hilbert Space of qudits.</p></div></section><section><div><pre><code class="nohighlight hljs">basis(register) -&gt; UnitRange</code></pre><p>Returns an <code>UnitRange</code> of the all the bits in the Hilbert space of given register.</p><pre><code class="language-julia-repl hljs">julia&gt; collect(basis(rand_state(3)))
8-element Vector{DitStr{2, 3, Int64}}:
 000 ₍₂₎
 001 ₍₂₎
 010 ₍₂₎
 011 ₍₂₎
 100 ₍₂₎
 101 ₍₂₎
 110 ₍₂₎
 111 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L804-L821">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.statevec" href="#YaoArrayRegister.statevec"><code>YaoArrayRegister.statevec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">statevec(r::ArrayReg) -&gt; array</code></pre><p>Return a state matrix/vector by droping the last dimension of size 1 (i.e. <code>nactive(r) = nqudits(r)</code>). See also <a href="registers.html#YaoArrayRegister.state"><code>state</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>statevec</code> is not type stable. It may cause performance slow down.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L370-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.relaxedvec" href="#YaoArrayRegister.relaxedvec"><code>YaoArrayRegister.relaxedvec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">relaxedvec(r::AbstractArrayReg) -&gt; AbstractArray</code></pre><p>Return a vector representation of state, with all qudits activated. See also <a href="registers.html#YaoArrayRegister.state"><code>state</code></a>, <a href="registers.html#YaoArrayRegister.statevec"><code>statevec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BitBasis.hypercubic" href="#BitBasis.hypercubic"><code>BitBasis.hypercubic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hypercubic(A::Array) -&gt; Array</code></pre><p>get the hypercubic representation for an array.</p></div></section><section><div><pre><code class="nohighlight hljs">hypercubic(r::ArrayReg) -&gt; AbstractArray</code></pre><p>Return the hypercubic representation (high dimensional tensor) of this register, only active qudits are considered. See also <a href="registers.html#YaoArrayRegister.rank3"><code>rank3</code></a> and <a href="registers.html#YaoArrayRegister.state"><code>state</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L391-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.rank3" href="#YaoArrayRegister.rank3"><code>YaoArrayRegister.rank3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rank3(r::ArrayReg)</code></pre><p>Return the rank 3 tensor representation of state, the 3 dimensions are (activated space, remaining space, batch dimension). See also <a href="registers.html#BitBasis.hypercubic"><code>hypercubic</code></a> and <a href="registers.html#YaoArrayRegister.state"><code>state</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L400-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.viewbatch" href="#YaoAPI.viewbatch"><code>YaoAPI.viewbatch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">viewbatch(register, i::Int) -&gt; AbstractRegister</code></pre><p>Returns the <code>i</code>-th single register of a batched register. The returned instance is a view of the original register, i.e. inplace operation changes the original register directly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = zero_state(5; nbatch=2);

julia&gt; apply!(viewbatch(reg, 2), put(5, 2=&gt;X));

julia&gt; measure(reg; nshots=3)
3×2 Matrix{DitStr{2, 5, Int64}}:
 00000 ₍₂₎  00010 ₍₂₎
 00000 ₍₂₎  00010 ₍₂₎
 00000 ₍₂₎  00010 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L92-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.transpose_storage" href="#YaoArrayRegister.transpose_storage"><code>YaoArrayRegister.transpose_storage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transpose_storage(register) -&gt; register</code></pre><p>Transpose the register storage. Sometimes transposed storage provides better performance for batched simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/register.jl#L200-L204">source</a></section></article><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><p>The list of arithmetic operations for <a href="registers.html#YaoArrayRegister.ArrayReg"><code>ArrayReg</code></a> include </p><ul><li><code>+</code></li><li><code>-</code></li><li><code>*</code></li><li><code>/</code> (scalar)</li><li><code>adjoint</code></li></ul><p>Then the inner product can be computed as follows.</p><pre><code class="language-julia hljs">julia&gt; reg = rand_state(3);

julia&gt; reg&#39; * reg
0.9999999999999998 + 0.0im</code></pre><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AdjointArrayReg</code>. Check Documenter&#39;s build log for details.</p></div></div><p>We also have some faster inplace versions of arithematic operations</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>regadd!, regsub!, regscale!,</code>. Check Documenter&#39;s build log for details.</p></div></div><p>We also define the following functions for state normalization, and distance measurement.</p><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize!(r::AbstractArrayReg)</code></pre><p>Normalize the register <code>r</code> by its 2-norm. It changes the register directly.</p><p><strong>Examples</strong></p><p>The following code creates a normalized GHZ state.</p><pre><code class="language-julia hljs">julia&gt; reg = product_state(bit&quot;000&quot;) + product_state(bit&quot;111&quot;);

julia&gt; norm(reg)
1.4142135623730951

julia&gt; isnormalized(reg)
false

julia&gt; normalize!(reg);

julia&gt; isnormalized(reg)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/operations.jl#L11-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoArrayRegister.isnormalized" href="#YaoArrayRegister.isnormalized"><code>YaoArrayRegister.isnormalized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isnormalized(r::ArrayReg) -&gt; Bool</code></pre><p>Returns true if the register <code>r</code> is normalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoArrayRegister/src/operations.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.fidelity" href="#YaoAPI.fidelity"><code>YaoAPI.fidelity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fidelity(register1, register2) -&gt; Real/Vector{&lt;:Real}
fidelity&#39;(pair_or_reg1, pair_or_reg2) -&gt; (g1, g2)</code></pre><p>Return the fidelity between two states. Calcuate the fidelity between <code>r1</code> and <code>r2</code>, if <code>r1</code> or <code>r2</code> is not pure state (<code>nactive(r) != nqudits(r)</code>), the fidelity is calcuated by purification. See also <a href="man/@ref"><code>pure_state_fidelity</code></a>, <a href="man/@ref"><code>purification_fidelity</code></a>.</p><p>Obtain the gradient with respect to registers and circuit parameters. For pair input <code>ψ=&gt;circuit</code>, the returned gradient is a pair of <code>gψ=&gt;gparams</code>, with <code>gψ</code> the gradient of input state and <code>gparams</code> the gradients of circuit parameters. For register input, the return value is a register.</p><p><strong>Definition</strong></p><p>The fidelity of two quantum state for qudits is defined as:</p><p class="math-container">\[F(ρ, σ) = tr(\sqrt{\sqrt{ρ}σ\sqrt{ρ}})\]</p><p>Or its equivalent form (which we use in numerical calculation):</p><p class="math-container">\[F(ρ, σ) = sqrt(tr(ρσ) + 2 \sqrt{det(ρ)det(σ)})\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg1 = uniform_state(3);

julia&gt; reg2 = zero_state(3);

julia&gt; fidelity(reg1, reg2)
0.35355339059327373</code></pre><p><strong>References</strong></p><ul><li>Jozsa R. Fidelity for mixed quantum states[J]. Journal of modern optics, 1994, 41(12): 2315-2323.</li><li>Nielsen M A, Chuang I. Quantum computation and quantum information[J]. 2002.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The original definition of fidelity <span>$F$</span> was from &quot;transition probability&quot;, defined by Jozsa in 1994, it is the square of what we use here.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L606-L654">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.tracedist" href="#YaoAPI.tracedist"><code>YaoAPI.tracedist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tracedist(register1, register2)</code></pre><p>Return the trace distance of <code>register1</code> and <code>register2</code>.</p><p><strong>Definition</strong></p><p>Trace distance is defined as following:</p><p class="math-container">\[\frac{1}{2} || A - B ||_{\rm tr}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg1 = uniform_state(3);

julia&gt; reg2 = zero_state(3);

julia&gt; tracedist(reg1, reg2)
1.8708286933869704</code></pre><p><strong>References</strong></p><ul><li>https://en.wikipedia.org/wiki/Trace_distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L657-L683">source</a></section></article><h2 id="Resource-management-and-addressing"><a class="docs-heading-anchor" href="#Resource-management-and-addressing">Resource management and addressing</a><a id="Resource-management-and-addressing-1"></a><a class="docs-heading-anchor-permalink" href="#Resource-management-and-addressing" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>add_qudits!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>add_qubits!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.append_qudits!" href="#YaoAPI.append_qudits!"><code>YaoAPI.append_qudits!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">append_qudits!(register, n::Int) -&gt; register
append_qudits!(n::Int) -&gt; λ(register)</code></pre><p>Add <code>n</code> qudits to given register in state |0&gt;. i.e. |psi&gt; -&gt; |000&gt; ⊗ |psi&gt;, increased bits have higher indices.</p><p>If only an integer is provided, then returns a lambda function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;01101&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2

julia&gt; append_qudits!(reg, 2)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 7/7
    nlevel: 2

julia&gt; measure(reg; nshots=3)
3-element Vector{DitStr{2, 7, Int64}}:
 0001101 ₍₂₎
 0001101 ₍₂₎
 0001101 ₍₂₎</code></pre><p>Note here, we read the bit string from right to left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L115-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.append_qubits!" href="#YaoAPI.append_qubits!"><code>YaoAPI.append_qubits!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">append_qubits!(register, n::Int) -&gt; register
append_qubits!(n::Int) -&gt; λ(register)</code></pre><p>Add <code>n</code> qudits to given register in state |0&gt;. It is an alias of <a href="registers.html#YaoAPI.append_qudits!"><code>append_qudits!</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L147-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.reorder!" href="#YaoAPI.reorder!"><code>YaoAPI.reorder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reorder!(reigster, orders)</code></pre><p>Reorder the locations of register by input orders. For a 3-qubit register, an order <code>(i, j, k)</code> specifies the following reordering of qubits</p><ul><li>move the first qubit go to <code>i</code>,</li><li>move the second qubit go to <code>j</code>,</li><li>move the third qubit go to <code>k</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The convention of <code>reorder!</code> is different from the <code>permutedims</code> function, one can use the <code>sortperm</code> function to relate the permutation order and the order in this function.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;010101&quot;);

julia&gt; reorder!(reg, (1,4,2,5,3,6));

julia&gt; measure(reg)
1-element Vector{DitStr{2, 6, Int64}}:
 000111 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L292-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.invorder!" href="#YaoAPI.invorder!"><code>YaoAPI.invorder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">invorder!(register)</code></pre><p>Inverse the locations of the register.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;010101&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 6/6
    nlevel: 2

julia&gt; measure(invorder!(reg); nshots=3)
3-element Vector{DitStr{2, 6, Int64}}:
 101010 ₍₂₎
 101010 ₍₂₎
 101010 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L318-L337">source</a></section></article><p>Only a subset of qubits that does not interact with other qubits can be removed, the best approach is first measuring it in computational basis first. It can be done with the <a href="registers.html#YaoAPI.measure!"><code>measure!</code></a> function by setting the first argument to <code>RemoveMeasured()</code>.</p><h2 id="Instruction-set"><a class="docs-heading-anchor" href="#Instruction-set">Instruction set</a><a id="Instruction-set-1"></a><a class="docs-heading-anchor-permalink" href="#Instruction-set" title="Permalink"></a></h2><p>Although we have matrix representation for Yao blocks, specialized instructions are much faster and memory efficient than using the matrix-matrix product. These instructions are specified with the <code>instruct!</code> function listed bellow.</p><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.instruct!" href="#YaoAPI.instruct!"><code>YaoAPI.instruct!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">instruct!([nlevel=Val(2), ]state, operator, locs[, control_locs, control_configs, theta])</code></pre><p>Unified interface for applying an operator to a quantum state. It modifies the <code>state</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>nlevel</code> is the number of levels in each qudit,</li><li><code>state</code> is a vector or matrix representing the quantum state, where the first dimension is the active qubit dimension, the second is the batch dimension.</li><li><code>operator</code> is a quantum operator, which can be <code>Val(GATE_SYMBOL)</code> or a matrix.</li><li><code>locs::Tuple</code> is a tuple for specifying the locations this gate applied.</li><li><code>control_locs::Tuple</code> and <code>control_configs</code> are tuples for specifying the control locations and control values.</li><li><code>theta::Real</code> is the parameter for the gate, e.g. <code>Val(:Rx)</code> gate takes a real number of its parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L43-L57">source</a></section></article><h2 id="Measurement"><a class="docs-heading-anchor" href="#Measurement">Measurement</a><a id="Measurement-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement" title="Permalink"></a></h2><p>We have a true measure function <code>measure!</code> that collapses the state after the measurement. We also have some &quot;cheating&quot; functions to facilitate classical simulation.</p><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.measure!" href="#YaoAPI.measure!"><code>YaoAPI.measure!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure!([postprocess,] [operator, ]register[, locs]; rng=Random.GLOBAL_RNG)</code></pre><p>Measure current active qudits or qudits at <code>locs</code>. If the operator is not provided, it will measure on the computational basis and collapse to a product state. Otherwise, the quantum state collapse to the subspace corresponds to the resulting eigenvalue of the observable.</p><p><strong>Arguments</strong></p><ul><li><code>postprocess</code> is the postprocessing method, it can be<ul><li><code>NoPostProcess()</code> (default).</li><li><code>ResetTo(config)</code>, reset to result state to <code>config</code>. It can not be used if <code>operator</code> is provided, because measuring an operator in general does not return a product state.</li><li><code>RemoveMeasured()</code>, remove the measured qudits from the register. It is also incompatible with the <code>operator</code> argument.</li></ul></li><li><code>operator::AbstractBlock</code> is the operator to measure.</li><li><code>register::AbstractRegister</code> is the quantum state.</li><li><code>locs</code> is the qubits to performance the measurement. If <code>locs</code> is not provided, all current active qudits are measured (regarding to active qudits,</li></ul><p>see <a href="man/@ref"><code>focus!</code></a> and <a href="registers.html#YaoAPI.relax!"><code>relax!</code></a>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>rng</code> is the random number generator.</li></ul><p><strong>Examples</strong></p><p>The following example measures a random state on the computational basis and reset it to a certain bitstring value.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = rand_state(3);

julia&gt; measure!(ResetTo(bit&quot;011&quot;), reg)
110 ₍₂₎

julia&gt; measure(reg; nshots=3)
3-element Vector{DitStr{2, 3, Int64}}:
 011 ₍₂₎
 011 ₍₂₎
 011 ₍₂₎

julia&gt; measure!(RemoveMeasured(), reg, (1,2))
11 ₍₂₎

julia&gt; reg  # removed qubits are not usable anymore
ArrayReg{2, ComplexF64, Array...}
    active qubits: 1/1
    nlevel: 2</code></pre><p>Measuring an operator will project the state to the subspace associated with the returned eigenvalue.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = uniform_state(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; print_table(reg)
000 ₍₂₎   0.35355 + 0.0im
001 ₍₂₎   0.35355 + 0.0im
010 ₍₂₎   0.35355 + 0.0im
011 ₍₂₎   0.35355 + 0.0im
100 ₍₂₎   0.35355 + 0.0im
101 ₍₂₎   0.35355 + 0.0im
110 ₍₂₎   0.35355 + 0.0im
111 ₍₂₎   0.35355 + 0.0im

julia&gt; measure!(repeat(3, Z, 1:3), reg)
-1.0 + 0.0im

julia&gt; print_table(reg)
000 ₍₂₎   0.0 + 0.0im
001 ₍₂₎   0.5 + 0.0im
010 ₍₂₎   0.5 + 0.0im
011 ₍₂₎   0.0 + 0.0im
100 ₍₂₎   0.5 + 0.0im
101 ₍₂₎   0.0 + 0.0im
110 ₍₂₎   0.0 + 0.0im
111 ₍₂₎   0.5 + 0.0im</code></pre><p>Here, we measured the parity operator, as a result,  the resulting state collapsed to the subspace with either even or odd parity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L441-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.measure" href="#YaoAPI.measure"><code>YaoAPI.measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure([, operator], register[, locs]; nshots=1, rng=Random.GLOBAL_RNG) -&gt; Vector{Int}</code></pre><p>Measure a quantum state and return measurement results of qudits. This measurement function a cheating version of <code>measure!</code> that does not collapse the input state. It also does not need to recompute the quantum state for performing multiple shots measurement.</p><p><strong>Arguments</strong></p><ul><li><code>operator::AbstractBlock</code> is the operator to measure.</li><li><code>register::AbstractRegister</code> is the quantum state.</li><li><code>locs</code> is the qubits to performance the measurement. If <code>locs</code> is not provided, all current active qudits are measured (regarding to active qudits,</li></ul><p>see <a href="man/@ref"><code>focus!</code></a> and <a href="registers.html#YaoAPI.relax!"><code>relax!</code></a>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>nshots::Int</code> is the number of shots.</li><li><code>rng</code> is the random number generator.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;110&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; measure(reg; nshots=3)
3-element Vector{DitStr{2, 3, Int64}}:
 110 ₍₂₎
 110 ₍₂₎
 110 ₍₂₎

julia&gt; measure(reg, (2,3); nshots=3)
3-element Vector{DitStr{2, 2, Int64}}:
 11 ₍₂₎
 11 ₍₂₎
 11 ₍₂₎</code></pre><p>The following example switches to the X basis for measurement.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = apply!(product_state(bit&quot;100&quot;), repeat(3, H, 1:3))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; measure(repeat(3, X, 1:3), reg; nshots=3)
3-element Vector{ComplexF64}:
 -1.0 + 0.0im
 -1.0 + 0.0im
 -1.0 + 0.0im

julia&gt; reg = apply!(product_state(bit&quot;101&quot;), repeat(3, H, 1:3))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; measure(repeat(3, X, 1:3), reg; nshots=3)
3-element Vector{ComplexF64}:
 1.0 - 0.0im
 1.0 - 0.0im
 1.0 - 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L375-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.select!" href="#YaoAPI.select!"><code>YaoAPI.select!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select!(dest::AbstractRegister, src::AbstractRegister, bits::Integer...) -&gt; AbstractRegister
select!(register::AbstractRegister, bits::Integer...) -&gt; register
select!(b::Integer) -&gt; f(register)</code></pre><p>select a subspace of given quantum state based on input eigen state <code>bits</code>. See also <a href="registers.html#YaoAPI.select"><code>select</code></a> for the non-inplace version. If the register is not provided, it returns a lambda expression that takes a register as the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = ghz_state(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; select!(reg, bit&quot;111&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 0/0
    nlevel: 2

julia&gt; norm(reg)
0.7071067811865476</code></pre><p>The selection only works on the activated qubits, for example</p><pre><code class="nohighlight hljs">julia&gt; reg = focus!(ghz_state(3), (1, 2))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 2/3
    nlevel: 2

julia&gt; select!(reg, bit&quot;11&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 0/1
    nlevel: 2

julia&gt; statevec(reg)
1×2 Matrix{ComplexF64}:
 0.0+0.0im  0.707107+0.0im</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Developers should overload <code>select!(r::RegisterType, bits::NTuple{N, &lt;:Integer})</code> and do not assume <code>bits</code> has specific number of bits (e.g <code>Int64</code>), or it will restrict the its maximum available number of qudits.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L523-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.select" href="#YaoAPI.select"><code>YaoAPI.select</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select(register, bits) -&gt; AbstractRegister</code></pre><p>The non-inplace version of <a href="registers.html#YaoAPI.select!"><code>select!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L574-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.collapseto!" href="#YaoAPI.collapseto!"><code>YaoAPI.collapseto!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collapseto!(register, config)</code></pre><p>Set the <code>register</code> to bit string literal <code>bit_str</code> (or an equivalent integer). About bit string literal, see more in <a href="man/@ref"><code>@bit_str</code></a>. This interface is only for emulation.</p><p><strong>Examples</strong></p><p>The following code collapse a random state to a certain state.</p><pre><code class="language-julia-repl hljs">julia&gt; measure(collapseto!(rand_state(3), bit&quot;001&quot;); nshots=3)
3-element Vector{DitStr{2, 3, Int64}}:
 001 ₍₂₎
 001 ₍₂₎
 001 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L340-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.probs" href="#YaoAPI.probs"><code>YaoAPI.probs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">probs(register) -&gt; Vector</code></pre><p>Returns the probability distribution of computation basis, aka <span>$|&lt;x|ψ&gt;|^2$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;101&quot;);

julia&gt; reg |&gt; probs
8-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 1.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L582-L603">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>most_probable,</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Density-matrices"><a class="docs-heading-anchor" href="#Density-matrices">Density matrices</a><a id="Density-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Density-matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.DensityMatrix" href="#YaoAPI.DensityMatrix"><code>YaoAPI.DensityMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityMatrix{D,T,MT&lt;:AbstractMatrix{T}} &lt;: AbstractRegister{D}
DensityMatrix{D}(state::AbstractMatrix)
DensityMatrix(state::AbstractMatrix; nlevel=2)</code></pre><p>Density matrix type, where <code>state</code> is a matrix. Type parameter <code>D</code> is the number of levels, it can also be specified by a keyword argument <code>nlevel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L712-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.density_matrix" href="#YaoAPI.density_matrix"><code>YaoAPI.density_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">density_matrix(register, locations)</code></pre><p>Returns the density matrix for qubits on <code>locations</code>.</p><p><strong>Examples</strong></p><p>The following code gets the single site reduce density matrix for the GHZ state.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = ghz_state(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; density_matrix(reg, (2,)).state
2×2 Matrix{ComplexF64}:
 0.5+0.0im  0.0+0.0im
 0.0-0.0im  0.5+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L759-L779">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.partial_tr" href="#YaoAPI.partial_tr"><code>YaoAPI.partial_tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partial_tr(ρ, locs) -&gt;</code></pre><p>Return a density matrix which is the partial traced on <code>locs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.purify" href="#YaoAPI.purify"><code>YaoAPI.purify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">purify(r::DensityMatrix; nbit_env::Int=nactive(r)) -&gt; ArrayReg</code></pre><p>Get a purification of target density matrix.</p><p><strong>Examples</strong></p><p>The following example shows how to measure a local operator on the register, reduced density matrix and the purified register. Their results should be consistent.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = ghz_state(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; r = density_matrix(reg, (2,));

julia&gt; preg = purify(r)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 1/2
    nlevel: 2

julia&gt; isapprox(expect(Z + Y, preg), 0.0; atol=1e-10)
true

julia&gt; isapprox(expect(Z + Y, r), 0.0; atol=1e-10)
true

julia&gt; isapprox(expect(put(3, 2=&gt;(Z + Y)), reg), 0.0; atol=1e-10)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/d00b3da4b3a161b98356692901f85cf69700add1/lib/YaoAPI/src/registers.jl#L724-L756">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>von_neumann_entropy, mutual_information,</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quick-start.html">« Quick Start</a><a class="docs-footer-nextpage" href="blocks.html">Blocks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Friday 10 June 2022 03:27">Friday 10 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
